/*  ||>>>====================----------     ----------====================<<<||				DRL File Tools v1.3		DEPENDENCIES:		<None>		(all additional procedures that are called from this script are		also inside this script).		This script contains service functions for work with files.	There are following functions in this file:			>>> DRL_file_open <<<		Description:			Returns contents of the file located at the given path			as an array of strings			with each file line as array element.			Each line is "strict", without \n at the end.		Usage:			DRL_file_open <full path to the file>		e.g.:			DRL_file_open "C:/test/MyTextFile.txt";		>>> DRL_file_read <<<		Description:			It's used in the previous function.			Takes ID of file previously opend with "fopen".			Returns contents of the file the same way			as in previous function.		Usage:			DRL_file_read(<file ID>);		>>> DRL_file_findIn <<<		Description:			Finds specified words in the file given as string array.			Takes 3 arguments: array of strings to search _in_ (file),			array of strings to search _for_ (keywords)			and the resulting strings array where words found in file			will be stored after function call.			The function itself returns int array which contains numbers			of lines in file where corresponding word was found.			The search founds only exact match with keyword. e.g. If you			searched for "abc_1" it will find all "abc_1" words, but no			"Aabc_1", "abc_12", "xyz_abc_1" etc.		Usage:			DRL_file_findIn (<array of file lines>, <array of words>, <array to store found words into>)		e.g.:			string $file[] = {				"A few strings",				"with some keywords",				"to search in"			};			string $words[] = {"A", "a", "strings", "words", "keywords", "search"};			string $found[] = {};			int $lines = DRL_file_findIn($file, $words, $found);			// Result:			// $found = {"A", "strings", "keywords", "search"}			// $lines = {1, 1, 2, 3}			// Note that returned lines array represent numbers of FILE LINES.			// The indexes of source array are smaller by 1.			>>> DRL_file_findInMulti <<<		Description:			This function is similar with previous one. But it takes an array			of several file paths as first argument rather than array of			single file lines.			It also requires one more variable as an argument, where will be			stored paths to file containing found corresponding keyword.			As in previous finction, this returns array of files' lines.		Usage:			DRL_file_findInMulti (<array of filepaths>, <array of words>, <array - found in file>, <array - found word>)			>>> DRL_fixPath <<<		Description:			Converts given file/folder path into unix-friendly format. Also allows to remove trailing slashes.		Usage:			DRL_fixPath (<string - path>, <boolean - whether to delete trailing slash or not>)			>>> DRL_makePath <<<		Description:			Checks whether the folder exists at the given path and creates it if not. Allows to forcefully create a folder			at this path, even if there's a file already at this path.			Returns path converted to unix-friendly format without trailing slash.		Usage:			DRL_makePath (<string - path>, <boolean - whether to overwrite a file with created dir or not>)	    ||>>>====================----------     ----------====================<<<||*/global proc string[] DRL_file_open(string $filePath) {	string $result[] = {};	string $path = DRL_fixPath($filePath, 1);	if (`filetest -r $path`) {		int $fileId = fopen($path,"r");		$result = `DRL_file_read($fileId)`;		fclose($fileId);	} else {		warning ("\nFile \"" + $path + "\" doesn't exist.\nEmpty array returned.");	}	return $result;}global proc string[] DRL_file_read(int $fileId) {	string $result[] = {};	int $k = -1;	string $line = "";	while (!feof($fileId)) {		$line = `fgetline $fileId`;		$line = `substitute "[\r\n]+$" $line ""`;		$k++;		$result[$k] = $line;	}	return $result;}global proc int[] DRL_file_findIn(string $file[], string $words[], string $result[]) {	int $stringsCount=`size $file`, $wordsCount=`size $words`;	int $lines[] = {};		if ($stringsCount>0 && $wordsCount>0) {		$result = {};		int $i=0, $k=-1;		for (; $i<$stringsCount; $i++) {			for ($j=0; $j<$wordsCount; $j++) {				if (					`match ("[^a-z_A-Z0-9$]+" + $words[$j] + "[^a-z_A-Z0-9]+") $file[$i]` != "" ||					`match ("^" + $words[$j] + "[^a-z_A-Z0-9]+") $file[$i]` != "" ||					`match ("[^a-z_A-Z0-9$]+" + $words[$j] + "$") $file[$i]` != "" ||					`match ("^" + $words[$j] + "$") $file[$i]` != ""					) {						$k++;						$result[$k] = $words[$j];						$lines[$k] = $i + 1;				}			}		}	}		return $lines;}global proc int[] DRL_file_findInMulti(string $files[], string $words[], string $inFile[], string $result[]) {	int $filesCount=`size $files`;	int $lines[] = {};		if ($filesCount>0 && `size $words`<1) {		$inFile = {};		$result = {};		int $i=0, $j, $k=-1;		string $tmpResWords[] = {};		int $tmpResLines[] = {};				for (; $i<$filesCount; $i++) {			string $file[] = `DRL_file_open $files[$i]`;			$tmpResLines = DRL_file_findIn ($file, $words, $tmpResWords);			int $tmpResLinesCount = `size $tmpResLines`;			for ($j=0; $j<$tmpResLinesCount; $j++) {				$k++;				$inFile[$k] = $files[$i];				$result[$k] = $tmpResWords[$j];				$lines[$k] = $tmpResLines[$j];			}		}	}		return $lines;}global proc string DRL_fixPath (string $path, int $fixDir) {	if (`size $path` < 1) {		warning "No path specified.";		return "";	}		string $result = $path;	$result = substituteAllString($result, "\\", "/");	while (`match "//+" $result` != "")		$result = `substitute "//+" $result "/"`;	if($fixDir)		$result = `substitute "/+$" $result ""`;		return $result;}global proc string DRL_makePath (string $path, int $forceCreate) {	if (`size $path` < 1) {		warning "No path specified.";		return "";	}			string $dir;		$dir = DRL_fixPath($path, 1);		if (`file -q -ex $dir` && !`filetest -d $dir`) {		if ($forceCreate) {			sysFile -del $dir;			warning ("There was a file at the given path.\nRemoved: " + $dir);		} else {			warning ("The following path already exists and is a file: " + $dir);			return "";		}	}		if (!`file -q -ex $dir`) {		sysFile -md $dir;		print ("The directory has been created: " + $dir + "\n");	}		return $dir;}global proc string DRL_refFile (string $file, string $namespace) {	if (!`filetest -r $file`)		error ("File doesn't exist: " + $file);		file -r -type "mayaAscii" -gr -loadReferenceDepth "all" -namespace $namespace -options "v=0" $file;		$rn = `referenceQuery -referenceNode $file`;	return $rn;}